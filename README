This repo contains some scripts for use with
[Open Shading Language in Blender Cycles](https://wiki.blender.org/index.php/User:DingTo/OpenShadingLanguage). Some are OSL scripts that may be used directly, while others are Python scripts that generate OSL scripts.

**Copyright**: All OSL scripts (whether generated by Python scripts or included in this repo) are
licensed [CC0](https://creativecommons.org/publicdomain/zero/1.0/). The Python scripts are
licensed CC-BY.

Script Generators
=================

These scripts generate OSL scripts based on the supplied command parameters, such as
operand types, operation to perform, and name to give the shader. Operand types can
be most of the types recognized by OSL, such as `float`, `point`, `color`, often even
`closure color`.

* `osl-gen-compare`

    generates a comparison between two inputs, and uses the result of that comparison to
    select from one of two other inputs for its output: it returns the first of the selection
    inputs if the comparison is false, the second if it is true. For example, the command

        ./osl-gen-compare --comptype=float --seltype=color --name=color_max lt

    generates a computation node script like this:

        shader color_max
          (
            float Cmp1 = float(0),
            float Cmp2 = float(0),
            color Arg1 = color(0),
            color Arg2 = color(0),
            output color Out = color(0)
          )
          {
            Out = Cmp1 < Cmp2 ? Arg2 : Arg1;
          } /*color_max*/

    which returns the selection input (`Arg1` or `Arg2` corresponding to the larger of the two
    same-numbered comparison inputs (`Cmp1` or `Cmp2`).

* `osl-gen-mix`

    generates a multiway mixer of 2 or more inputs according to their relative assigned weights.
    Thus, the actual value of each weight does not matter, only its proportion in comparison
    to the total sum (which must not be 0). For comparison, Blender’s “MixRGB” and “Mix Shader”
    node types take two inputs and a single weight factor that blends between the two inputs.
    Whereas the mixers generated by `osl-gen-mix` can have any number of inputs. Also, you can
    ask for an output giving the summed input weights, to allow correct cascading of multiple
    multiway mixers, so that they behave like a single one. For example, the command

        ./osl-gen-mix --name=mix3_shader --type=closure\ color --inputs=3

    generates a shader node script like this:

        shader mix3_shader
          (
            closure color Input1 = 0,
            float Weight1 = 1,
            closure color Input2 = 0,
            float Weight2 = 1,
            closure color Input3 = 0,
            float Weight3 = 1,
            output closure color Output = 0
          )
          {
            float Weight = Weight1 + Weight2 + Weight3;
            Output = (Input1 * Weight1 + Input2 * Weight2 + Input3 * Weight3) * (1 / Weight);
          } /*mix3_shader*/

    which can be used to mix the outputs of 3 other Cycles shaders in any relative proportions.

* `osl-gen-multi`

    generates a cascaded arithmetic or comparison operation across multiple operands.
    The currently-supported operations are

    + `add` -- sum of all the operands
    + `mul` -- product of all the operands
    + `max` -- maximum of all the operands
    + `min` -- minimum of all the operands

    For example, the command

        ./osl-gen-multi --name=sum --type=float --input=5 add

    generates a computation node script like this

        shader sum
          (
            float Input1 = float(0),
            float Input2 = float(0),
            float Input3 = float(0),
            float Input4 = float(0),
            float Input5 = float(0),
            output float Output = float(0)
          )
          {
            Output = Input1 + Input2 + Input3 + Input4 + Input5;
          } /*sum*/

    which computes the sum of 5 input float values.

* `osl-gen-panel`

    generates a node that can be used to render a panel of multicoloured
    lights or an array of windows on a highrise building.

* `osl-gen-rand-pick`

    generates a node that randomly picks from its inputs based on assigned
    relative probability weights.

* `osl-gen-select`

    generates a node that selects from one of its inputs based on an input
    integer within a specified range. The selection type may be any of the
    usual OSL types, including “closure color”. You can specify a default
    for the selector value if the actual value is outside the valid range.

    For example, the command

        ./osl-gen-select --seltype=closure\ color --name=select4_shader 1 4

    generates a shader node script like this

        shader select4_shader
          (
            int Sel = 0,
            closure color In1 = 0,
            closure color In2 = 0,
            closure color In3 = 0,
            closure color In4 = 0,
            output closure color Out = 0
          )
          {
            if (Sel == 1)
                Out = In1;
            else if (Sel == 2)
                Out = In2;
            else if (Sel == 3)
                Out = In3;
            else if (Sel == 4)
                Out = In4;
          } /*select4_shader*/

    which selects from 4 different input shaders according to the Sel value.

Prewritten Scripts
==================

* `atan2.osl`

    This is an alternative to the “atan” function in Cycles’s built-in “Math” node.
    Unlike that, this one takes both its X- and Y- inputs into account, and returns
    an angle that can cover the full circle.

* `pi.osl`

    Returns the specified multiple of pi.

* `polar_to_rect.osl`

    Interprets its input point as (*r*, *theta*, *phi*) polar coordinates (angles
    *theta* and *phi* being in radians), and returns the output as converted
    (*x*, *y*, *z*) Cartesian coordinates.

    This can be used for 3D or 2D coordinates; for 2D, leave the input *phi* as
    zero and the output *z* will be zero and can be ignored.

* `rand_int.osl`

    Generates a pseudorandom uniformly-distributed integer over a specified
    range. The output depends only on the integer parts of the input coordinate
    and time values; you can get a different granularity simply by scaling these.

* `rect_to_polar.osl`

    Converts its input (*x*, *y*, *z*) Cartesian coordinates to (*r*, *theta*, *phi*)
    polar coordinates as its output.

    This can be used for 3D or 2D coordinates; for 2D, leave the input *z* as
    zero and the output *phi* will be zero and can be ignored.

* `scale_coords.osl`

    This is a simpler alternative to Cycles’ “Vector Mapping” node. This just does
    uniform scaling of coordinates. Also the scale factor is a node input, and so
    can be computed from other values.

Lawrence D'Oliveiro <ldo@geek-central.gen.nz>
2016 April 11
