#!/usr/bin/python3
#+
# This script generates an Open Shading Language shader that
# produces as its output the specified mixture of cosine
# peak terms. Invoke it as follows:
#
#     osl-gen-spherical-lobes --name=«name» «m» «n»
#
# where «name» is the name to give to the shader, «m» is the
# number of axial lobes, and «n» is the number of radial lobes.
#
# Each component will be controlled by 3 parameters: the angle at
# which to position the centre of the lobe, the intensity to give it,
# and the power to which to raise the cosine term (which controls the
# sharpness of the peak).
#
# The sum of the axial lobes is multiplied by the sum of the
# radial lobes to give the combined output.
#
# Copyright 2018 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
# Licensed under CC-BY <http://creativecommons.org/licenses/by/4.0/>.
#-

import sys
import itertools
import getopt

#+
# Mainline
#-

def format_number(x) :
    return \
        "%%.%dg" % precision % x
#end format_number

opts, args = getopt.getopt \
  (
    sys.argv[1:],
    "",
    ["name=", "precision="]
  )
shader_name = None
precision = 7
for keyword, value in opts :
    if keyword == "--name" :
        shader_name = value
    elif keyword == "--precision" :
        try :
            precision = int(value)
        except ValueError :
            precision = -1
        #end try
        if precision < 0 :
            raise getopt.GetoptError("bad --precision value")
        #end if
    #end if
#end for
if shader_name == None :
    raise getopt.GetoptError("missing --name")
#end if
if len(args) != 2 :
    raise getopt.GetoptError("need exactly two args")
#end if
m = int(args[0])
n = int(args[1])
if m < 0 or n < 0 :
    raise getopt.GetoptError("args must be non-negative")
#end if

sys.stdout.write \
  (
        "shader %(name)s\n"
        "  (\n"
        "%(weight_defs)s\n"
        "    normal Direction = N,\n"
        "    output float Result = 1\n"
        "  )\n"
        "  /* generated by osl-gen-spherical-lobes. */\n"
        "  {\n"
        "    float phi = atan2(Direction[1], Direction[0]);\n"
        "    float theta = atan2(hypot(Direction[1], Direction[0]), Direction[2]);\n"
        "    Result = max\n"
        "      (\n"
        "            (\n"
        "                %(axial_terms)s\n"
        "            )\n"
        "        *\n"
        "            (\n"
        "                %(radial_terms)s\n"
        "            ),\n"
        "        0\n"
        "      );\n"
        "  } /*%(name)s*/\n"
    %
        {
            "name" : shader_name,
            "weight_defs" : "\n".join
              (
                map
                  (
                    lambda v : "    float %s = %s" % (v[0], format_number(v[1])) + ",",
                        list
                          (
                            itertools.chain
                              (
                                *list
                                  (
                                    [
                                        ("Angle_axial_%d" % (i + 1), i / m),
                                        ("Intens_axial_%d" % (i + 1), 0),
                                        ("Power_axial_%d" % (i + 1), 1),
                                    ]
                                    for i in range(m)
                                  )
                              )
                          )
                    +
                        list
                          (
                            itertools.chain
                              (
                                *list
                                  (
                                    [
                                        ("Angle_radial_%d" % (i + 1), i / n),
                                        ("Intens_radial_%d" % (i + 1), 0),
                                        ("Power_radial_%d" % (i + 1), 1),
                                    ]
                                    for i in range(n)
                                  )
                              )
                          )
                  )
              ),
            "axial_terms" :
                "\n            +\n                ".join
                  (
                        "Intens_axial_%(i)d * pow((cos(theta - Angle_axial_%(i)d * M_PI) + 1)"
                        " / 2, Power_axial_%(i)d)"
                    %
                        {"i" : i + 1}
                    for i in range(m)
                  ),
            "radial_terms" :
                "\n            +\n                ".join
                  (
                        "Intens_radial_%(i)d * pow((cos(phi - Angle_radial_%(i)d * 2 * M_PI)"
                        " + 1) / 2, Power_radial_%(i)d)"
                    %
                        {"i" : i + 1}
                    for i in range(m)
                  ),
        }
  )
